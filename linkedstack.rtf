{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green120\blue215;\red0\green128\blue0;\red0\green0\blue0;\red255\green0\blue0;\red128\green0\blue128;\red0\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title linkedstack.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0\i /*
\par  * File:    stack.c
\par  * Author:  zentut.com
\par  * Purpose: linked stack implementation
\par  */
\par 
\par \i0\cf1 #include <stdio.h>
\par 
\par \cf2\b struct\b0  node
\par \cf3\b \{
\par \b0\cf2     \b int\b0  data\cf3\b ;
\par \b0\cf2     \b struct\b0  node\cf3\b *\b0\cf2  next\cf3\b ;
\par \};
\par 
\par \b0\cf0\i /*
\par     init the stack
\par */
\par \i0\cf2\b void\b0  init\cf3\b (\cf2 struct\b0  node\cf3\b *\b0\cf2  head\cf3\b )
\par \{
\par \b0\cf2     head \cf3\b =\b0\cf2  NULL\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*
\par     push an element into stack
\par */
\par \i0\cf2\b struct\b0  node\cf3\b *\b0\cf2  push\cf3\b (\cf2 struct\b0  node\cf3\b *\b0\cf2  head\cf3\b ,\cf2 int\b0  data\cf3\b )
\par \{
\par \b0\cf2     \b struct\b0  node\cf3\b *\b0\cf2  tmp \cf3\b =\b0\cf2  \cf3\b (\cf2 struct\b0  node\cf3\b *)\b0\cf2 malloc\cf3\b (\cf2 sizeof\cf3 (\cf2 struct\b0  node\cf3\b ));
\par \b0\cf2     \b if\cf3 (\b0\cf2 tmp \cf3\b ==\b0\cf2  NULL\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         exit\cf3\b (\b0\cf4 0\cf3\b );
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     tmp\cf3\b ->\b0\cf2 data \cf3\b =\b0\cf2  data\cf3\b ;
\par \b0\cf2     tmp\cf3\b ->\b0\cf2 next \cf3\b =\b0\cf2  head\cf3\b ;
\par \b0\cf2     head \cf3\b =\b0\cf2  tmp\cf3\b ;
\par \b0\cf2     \b return\b0  head\cf3\b ;
\par \}
\par \b0\cf0\i /*
\par     pop an element from the stack
\par */
\par \i0\cf2\b struct\b0  node\cf3\b *\b0\cf2  pop\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 head\cf3\b ,\cf2 int\b0  \cf3\b *\b0\cf2 element\cf3\b )
\par \{
\par \b0\cf2     \b struct\b0  node\cf3\b *\b0\cf2  tmp \cf3\b =\b0\cf2  head\cf3\b ;
\par \b0\cf2     \cf3\b *\b0\cf2 element \cf3\b =\b0\cf2  head\cf3\b ->\b0\cf2 data\cf3\b ;
\par \b0\cf2     head \cf3\b =\b0\cf2  head\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2     free\cf3\b (\b0\cf2 tmp\cf3\b );
\par \b0\cf2     \b return\b0  head\cf3\b ;
\par \}
\par \b0\cf0\i /*
\par     returns 1 if the stack is empty, otherwise returns 0
\par */
\par \i0\cf2\b int\b0  empty\cf3\b (\cf2 struct\b0  node\cf3\b *\b0\cf2  head\cf3\b )
\par \{
\par \b0\cf2     \b return\b0  head \cf3\b ==\b0\cf2  NULL \cf3\b ?\b0\cf2  \cf4 1\cf2  \cf3\b :\b0\cf2  \cf4 0\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*
\par     display the stack content
\par */
\par \i0\cf2\b void\b0  display\cf3\b (\cf2 struct\b0  node\cf3\b *\b0\cf2  head\cf3\b )
\par \{
\par \b0\cf2     \b struct\b0  node \cf3\b *\b0\cf2 current\cf3\b ;
\par \b0\cf2     current \cf3\b =\b0\cf2  head\cf3\b ;
\par \b0\cf2     \b if\cf3 (\b0\cf2 current\cf3\b !=\b0\cf2  NULL\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         printf\cf3\b (\cf5 "Stack: "\cf3 );
\par \b0\cf2         \b do
\par \b0         \cf3\b \{
\par \b0\cf2             printf\cf3\b (\cf5 "%d "\cf3 ,\b0\cf2 current\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2             current \cf3\b =\b0\cf2  current\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2         \cf3\b \}
\par \b0\cf2         \b while\b0  \cf3\b (\b0\cf2 current\cf3\b !=\b0\cf2  NULL\cf3\b );
\par \b0\cf2         printf\cf3\b (\cf5 "\\n"\cf3 );
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     \b else
\par \b0     \cf3\b \{
\par \b0\cf2         printf\cf3\b (\cf5 "The Stack is empty\\n"\cf3 );
\par \b0\cf2     \cf3\b \}
\par 
\par \}
\par }